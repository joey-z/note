## 两个关键字

- new/delete

  - 是C++中的关键字
  - 在c中没有文件（stdlib.h）是不能用的　c++可以直接用
  - new 按数据类型分空间大小　（会保证至少给正好的空间　或者更多）
  - ？？malloc是根据

- 初始化`Test t5 = t3`

- 赋值`Test t5; t5 = t3;  `

- 不能用局部变量返回引用

- 命名空间的嵌套

  ```c++
  #include <iostream>
  
  ```

- 类与对象

  - 访问权限

    - public(公共访问权限)

    - private(私有的访问权限)

    - protected(受保护的访问权限)

      ```c++
      #include <isotream>
      using std::cin;
      using std::cout;
      using std::endl;
      class Test {
          private:
              int i;
          	int j;
          public:
          	int a;
          	int getI() {
              	return i;
          	}
          	int getJ() {
              	return j;
          	}	
          	int getA() {
              	return a;
          	}
          	void setI(int value) {
              	i = value;
              	return ;
          	}
      };
      int main() {
          Test t;
          Test *t1 = new Test;
          t.a = 5;
          t1->a = 10;
          cout << t.getI() << endl;
          cout << t.a　<< " " << t1->a << endl; 
          return 0;
      }
      ```

      

  - 访问修改类里面的对象时要通过　去做

- 构造函数

  - | 构造/析构函数           | 使用方法            |
    | ----------------------- | ------------------- |
    | 默认构造函数            | People a;           |
    | People(string name);    | People a("hug");    |
    | People(const People &a) | 拷贝构造，与=不等价 |
    | ～People();             | 无                  |

    全局区变量是有初值的　如果没初始化初值是０

    栈区堆区没有　是一个随机值　

    - 特点：
      - 没有返回值类型
      - 函数名必须与类名相同
      - 定义对象时自动调用
    - 构造函数可以重载（同一个类属于同一个作用域）
    - 使用无参的构造函数不能写成`Test t3();`会被当做函数声明，要写成`Test t3;`
    - 当一个类是空类的时候，编译器会默认提供１个无参的构造函数

  - 构造函数的手动调用

  

- ```c++
  /*要求：开发一个数组类
  解决segmentfault:
  １．提供和获取长度的元素
  ２．提供获取数组元素的函数
  ３．提供修改数组元素的函数
  */
  #include <iostream>
  using namespace std;
  
  int main() {
      return 0;
  }
  
  ```

  拷贝构造函数

  - 当类中没有定义拷贝构造函数时会默认定义一个拷贝构造函数

  - 仅仅进行简单的值复制

  - 用已经？？初始化一个新的对象

  - 函数名是　类名（const class）一定要进行深拷贝　浅拷贝是拷贝之后物理状态相同　就是指向同一个地方　深拷贝是逻辑状态相同（对比了链表）

  - 手动实现拷贝构造函数必须深拷贝

  - ```c++
    #include <iostream>
    using std::cin;
    using std::cout;
    using std::endl;
    class Test {
    
        private:
        	int a;
        	int *p;
        public:
        Test() {
        	p = new int(1);
        }
        Test(const )
    }
    int main() {
        return 0;
    }
    ```

- 必须使用初始化列表来初始化

  - const 成员属性（真正常量/readonly?）
  - 类属性（类里有带参）
  - 注意事项：
    - 初始化列表的初始化顺序与成员属性的声明顺序相同
    - 初始化顺序与初始化列表中位置无关
    - 初始化列表优先函数体执行

- 尽量不要去使用全局对象（没有标准的顺序，用的时候可能没有）

- ｃ++标准中没有规定全局对象的构造顺序，所以不同的编译器

- 先父母再朋友再自己，析构顺序与构造顺序相反

- static 

  - 属于整个类　
  - 生命周期是整个程序　
  - 可以通过类名直接访问公有的静态成员变量
  - 所有对象都共享
  - 静态成员变量访问级别

- 静态成员方法的特性

  - 不依赖对象去访问属性
  - 静态成员函数不能直接访问成员变量

- 对象内存中存储方式

  - 对象
    - 属性　程序中要改变
    - 方法（函数）程序中不需要变得
    - 在内存中属性是自己的，方法是公有的
    - this指针是某一个对象的地址（静态成员函数无this）
    - 构造函数也是成员函数有this指针

- const对象的性质

  - const classname 变量名
  - 只读对象（里面的属性都是只读的　不能当左值用）
  - 在编译器里只读对象的成员属性不能被改变()
  - const 对象只能调用const 方法（const 方法　Type 函数（）const）

- const 方法定义

  - 类外 `Type classname::function() const {}`
  - 类内　`Type function() const {}`

- const 方法特性

  - const 对象只能调用const方法
  - const成员函数，内部只能调用const方法
  - const成员函数中不能更改变量的值

- 继承就是为了代码复用

- 返回值优化

  ```c++
  	> File Name: 0108.cpp
  	> Author: Zoe 
  	> Mail: 
  	> Created Time: 2019年01月08日 星期二 18时13分45秒
   ************************************************************************/
  
  #include <iostream>
  using std::cin;
  using std::cout;
  using std::endl;
  class Test {
      private:
          int i;
      public:
      Test(int v) {
          i = v;   
          cout << "Test(int i) : i = " << i << endl;
      }
      Test() {
          //Test(100);//产生了临时对象(密名对象) 生命周期/作用域只有这一行语句
          i = 0;
          cout << "Test() : i = " << i << endl;
      }
      Test(const Test &t) {
          i = t.i;//?? 
          cout << "Test(const Test &t) : i = " << i << endl; 
      }
      void printI() {
          cout << "i = " << i << endl;
      }
  };
  
  int main() {
      Test t = Test(100); //t = 10;
      t.printI();
      return 0;
  }
  
  ```

  

- 函数形参额初始化

`g++ test.cpp -fno-elide-constructors//默认开着返回值优化 执行此命令关掉`

## 继承

- 继承是类跟类之间的一种关系（继承 组合）

- 组合关系：

  - 类的对象被当做类的属性

  - 其他类的生命周期与当前类对象相同
  - 成员对象在用法上与普通成员相同

- 继承关系：类跟类的一种关系——单向关系

  ```c++
  //用法
  class A();
  class B:
  ```

  - 子类继承了父类的所有属性和方法（行为）
  - 子类是一种特殊的父类
  - 子类对象也可以当父类对象
  - **子类可以添加自己的属性和方法，还可以重写父类中的方法**

- 所有类的成员共享一套成员方法

继承方式（横排）

子类从父类中继承过来的属性方法访问权限（竖列）

![](/home/zoe/截图/c++/继承中子类的访问权限.png)

