一.讲课
1.原码 也叫符号-绝对值码
最高位0 表示正值 1 表示负值 其余二进制位是该数字的绝对值的二进制位
原码简单易懂 加减运算复杂 存在加减乘除死中运算 使CPU设计困难 增加CPU的复杂度 零的表示不唯一
2.反码
运算不便 也没有在计算机中使用
3.移码
表示数值平移N位 N称为移码量 
移码主要用于浮点数的阶码的存储(浮点数存储需要用到阶码 阶码用移码来表示)
4.补码(主要解决整数的存储) 十进制转十六进制转二进制 
十进制转二进制
	正整数转二进制
除2取余 直至商为0 余数倒叙排序 
	负整数转二进制
先求与该负数相对应的正整数的补码 然后将所有位取反 末尾加1 不够位数时 左边补0 
	0转二进制
	0000 0000 0000 0000 0000 0000 0000 0000(补码的0的值是唯一的)
二进制转十进制
	如果首位为0 则表明是正整数 按普通方法来求
	如果首位是1 则表明是负整数 将所有为取反 末位加1 所得数字就是该负数的绝对值

二.

1.由计算机的硬件决定,任何存储与计算机中的数据,其本质都是以二进制码进行存储.

2.计算机不能直接做减法,它的减法是通过加法来实现的.

3.从硬件的角度看,只有正数加负数才算减法.
  正数与正数相加 负数与负数相加 其实都可以通过加法器直接相加
(原码 反码 补码产生过程就是为了解决计算机做减法和引入符号位(正号和负号)的问题)
  补码正好等于反码加1罢了

4.冯诺依曼提出的经典计算机体系结构框架 
一台计算机由运算器(只有加法运算器 据说一开始有减法运算器 后来由于减法器硬件开销太大 被拿掉) 控制器 存储器 输入设备和输出设备组成

5.原码 
是最简单的机器数表示法 用最高位表示符号位 1表示负号 0表示正号 其他位存放该数的二进制绝对值 
0001 + 0010 = 0011 (1 + 2 = 3)
0000 + 1000 = 1000 (+0 + (-0) = -0
0001 + 1001 = 1010 (1 + (-1) = -2(????)
正数之间的加法通常是不会出错的 正数与负数相加 负数与负数相加 会引起莫名其妙的结果 是由符号位引起的
原码 直观易懂 易于正值转换 但用来实现加减法的话 运算规则太复杂 于是 有了反码

6.反码 
正数的反码还是等于原码 负数的反码就是它的原码除符号位外,按位取反
(原码最大的问题在于一个数加上他的相反数不等于零 等于负的这个数的二倍)
 0001 + 1001 = 1010 (1 + (-1) = -2) 0010 + 1010 = 1100 (2 + (-2) = -4) 
 用反码解决相反数问题 
 0001 + 1110 = 1111 (1 + (-1) = -0 )
 负数相加
 1110 + 1100 = 1010 (-1 + (-3) = -5)???
 相反数的问题解决了 两个负数相加的出错了 
 但是两个正数相加 两个负数相加都是加法问题 只有正数+负数才是减法问题 只要正数+负数不出错 问题就解决了 
 在源码表示法中两个负数相加 在不溢出的情况下就只有符号位出错了 
 (1001 + 1010 = 0011)
 反码的负数相加出错 实现两个负数相加是 将负数反码包括符号位全部按位取反相加 然后将符号位强制置为1 就可以了
 但是我们还不满足 0001 + 1110 = 1111 (1 + (-1) = -0) ??? 

7.补码 正数的补码等于他的原码 负数的补码等于反码+1
  在<计算机组成原理中> 补码的另外一种算法是 
负数的补码等于他的原码自低位向高位 尾数的第一个'1' '0' 保持不变 左边的各位按位取反 符号位不变 

8.移码
原码、反码、补码都是有符号定点数的表示方法（日常生活中通常都使用有符号数，定点数对应的就是浮点数，即小数），反码、补码是为了简化二进制数的减法运算；
移码常用来比较大小，一般会把浮点数的阶码用移码表示，说的再通俗一点，你把数值用移码表示出来可以一眼看出他们的大小。这样很容易判断阶码的大小，移码可用于简化浮点数的乘除法运算。

总结
反码：解决负数加法运算问题，将减法运算转换为加法运算，从而简化运算规则；
补码：解决负数加法运算正负零问题，弥补了反码的不足。
总之，反码与补码都是为了解决负数运算问题，跟正数没关系，因此，不管是正整数还是正小数，原码，反码，补码都全部相同。
1、正数的原码、补码、反码均为其本身；
2、负数（二进制）的原码、补码、反码公式：
    反码 = 原码（除符号位外）每位取反
    补码 = 反码 + 1
    反码 = 补码 - 1
    移码 = 补码符号位取反
